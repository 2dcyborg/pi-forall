> {-# LANGUAGE TemplateHaskell, FlexibleInstances, MultiParamTypeClasses, FlexibleContexts, UndecidableInstances, ViewPatterns #-}


> module Syntax where

> import Generics.RepLib hiding (Data,Refl)

> import Unbound.LocallyNameless hiding (Data,Refl)   -- variable binding
> import Text.ParserCombinators.Parsec.Pos       -- source positions for error messages

> import Data.Set (Set)
> import qualified Data.Set as S
> import Data.Maybe (fromMaybe)

> data Hint = Hint TName Term 

> type TName = Name Term

> wildcardName :: TName
> wildcardName = string2Name "_"

> type MName  = Name Module

> data DataCon
> type DCName = String

> data TyCon
> type TCName = Name TyCon

> 
> data Arg  = Arg Term | Irr Term deriving (Show)
> unArg :: Arg -> Term
> unArg (Arg t) = t
> unArg (Irr t) = t
 

> data Term = 
>      Var TName                          -- | variables       'x'
>    | Lam (Bind (TName, Maybe (Embed Term)) Term)              
>                                         -- | abstraction     '\x. b'
>    | App Term Term                      -- | application     'a b'
>    | Type Int                           -- | universe level  'Type i' 
>    | Pi (Bind (TName, Embed Term) Term) -- | function type   '(x:A) -> b'

>    -- practical matters
>    | Ann Term Term       -- | Annotated terms '( x : A )'   
>    | Paren Term          -- | parenthesized term, useful for pretty printing
>    | Pos SourcePos Term  -- | marked source position, for error messages
>    | TrustMe             -- | an axiom 'TRUSTME', inhabits all types 

>    -- inferring types
>    | UniVar UName        -- | unification variables
>    | InferMe

>    -- equality
>    | TyEq Term Term     -- | Equality type  'a = b'
>    | Refl (Maybe Term)  -- | Proof of equality
>    | Conv Term Term (Maybe (Bind TName Term)) 
>                         -- | equality elimination
>    | Contra Term (Maybe Term)  -- | @contra a@ 

>    -- inductive datatypes
>    | TCon TCName [Term]     -- | type constructors (fully applied)
>    | DCon DCName [Arg]      -- | term constructors (fully applied)
>    | Case Term [Match]
>    | Ind Epsilon (Bind (TName, TName) Term)           


>    -- irrelevant arguments
>    | LamErased (Bind (TName, Maybe (Embed Term)) Term)
>    | AppErased Term Term
>    | PiErased (Bind (TName, Embed Term) Term)

>    -- | A let expression (bound name, equality name, value)
>    | Let Epsilon (Bind (TName, TName, Embed Term) Term)



>       deriving (Show)

> -- | A 'Match' represents a case alternative. 
> data Match = Match (Bind Pattern Term) deriving (Show)
> 

> data Pattern = PatCon DCName [Pattern]
>              | PatVar TName deriving (Show)
> 

> pat2Term :: Pattern -> Term
> pat2Term (PatCon dc pats) = DCon dc (map (Arg . pat2Term) pats)
> pat2Term (PatVar x) = Var x


> data UnificationVar
> type UName  = Name UnificationVar
 
> -- | Epsilon annotates whether an abstraction 
> -- (resp. application) is implicit or explicit.
> data Epsilon = Runtime | Erased
>      deriving (Eq,Show,Read,Bounded,Ord)
> 
> orEps :: Epsilon -> Epsilon -> Epsilon
> orEps Erased _ = Erased
> orEps _ Erased = Erased
> orEps Runtime Runtime = Runtime


> -- | Partial inverse of Pos
> unPos :: Term -> Maybe SourcePos
> unPos (Pos p _) = Just p
> unPos _         = Nothing
> 
> -- | Tries to find a Pos anywhere inside a term
> unPosDeep :: Term -> Maybe SourcePos
> unPosDeep = something (mkQ Nothing unPos)

> -- | Tries to find a Pos inside a term, otherwise just gives up.
> unPosFlaky :: Term -> SourcePos
> unPosFlaky t = fromMaybe (newPos "unknown location" 0 0) (unPosDeep t)


> data ConstructorNames = ConstructorNames {
>                           tconNames :: Set TCName,
>                           dconNames :: Set DCName
>                         }
>   deriving Show
> 
> emptyConstructorNames :: ConstructorNames 
> emptyConstructorNames = ConstructorNames S.empty S.empty
> 
> 
> -- | A Module has a name, a list of imports, a list of declarations,
> --   and a list of constructor names (which affect parsing).     
> data Module = Module { moduleName :: MName,
>                        moduleImports :: [ModuleImport],
>                        moduleEntries :: [Decl],
>                        moduleConstructors :: ConstructorNames
>                      }
>             deriving (Show)
> 
> -- | A ModuleImport is just a name (for now).
> newtype ModuleImport = ModuleImport MName
>             deriving (Show,Eq)
> 
> data Decl = Sig  TName  Term
>           | Axiom TName Term
>           | Def TName Term
>           | Data TCName Telescope Int [ConstructorDef]
>           | AbsData TCName Telescope Int
>   deriving (Show)
> 
> 
> -- | A Constructor has a name and a telescope of arguments
> data ConstructorDef = ConstructorDef SourcePos DCName Telescope
>   deriving (Show)
> 
> -------------
> -- Telescopes
> -------------
> 
> 
> data Telescope = Empty
>                | Cons (Rebind (TName, Embed Term) Telescope)
>                | ConsErased (Rebind (TName, Embed Term) Telescope)
>   deriving (Show)
> 
> --------------
> -- Basic query and manipulation functions on source terms
> --------------
> isVar :: Term -> Maybe TName
> isVar (Pos _ t) = isVar t
> isVar (Paren t) = isVar t
> isVar (Var n)   = Just n
> isVar _         = Nothing
> 

> isTyEq :: Term -> Maybe (Term, Term)
> isTyEq (Pos _ t) = isTyEq t
> isTyEq (Paren t) = isTyEq  t
> isTyEq (TyEq ty0 ty1) = Just (delPosParenDeep ty0, delPosParenDeep ty1)
> isTyEq _ = Nothing
> 
> isNumeral :: Term -> Maybe Int
> isNumeral (Pos _ t) = isNumeral t
> isNumeral (Paren t) = isNumeral t
> isNumeral (DCon c []) | c== "Zero" = Just 0
> isNumeral (DCon c [Arg t]) | c==  "Succ" =
>   do n <- isNumeral t ; return (n+1)
> isNumeral _ = Nothing
> 


> -- Todo: see if these are still needed.
> delPosParenDeep :: Term -> Term
> delPosParenDeep = everywhere (mkT delPosParen)
>   where delPosParen :: Term -> Term
>         delPosParen (Pos _ tm)             = tm
>         delPosParen (Paren tm)             = tm
>         delPosParen tm                     = tm


> -- Infered vs Explicit arguments. 
> -- Defining a special-case Alpha instance means that aeq/acompare will not
> -- look at these annotations, but one can still distinguish them by pattern-matching.
> data Explicitness = Explicit | Inferred
>   deriving Show
> 
> instance Alpha Explicitness where
>    aeq' c _ _  = True
>    acompare' c _ _  = EQ


-------------------
-- LangLib instances
--------------------

> -- Defining SourcePos abstractly means that they get ignored when comparing terms.
> derive_abstract [''SourcePos]
> instance Alpha SourcePos
> instance Subst b SourcePos

> derive [''Epsilon, ''Explicitness, ''Term, ''Match, 
>         ''Pattern, ''Telescope, ''Module, ''DataCon, ''TyCon, ''Decl, 
>         ''ConstructorNames, ''ModuleImport, ''ConstructorDef, 
>         ''UnificationVar, ''Arg]

> instance Alpha Term
> instance Alpha Match
> instance Alpha Pattern
> instance Alpha Epsilon
> instance Alpha Telescope
> instance Alpha Arg
> 
> instance Subst Term Term where
>   isvar (Var x) = Just (SubstName x)
>   isvar _ = Nothing
> 
> instance Subst Term Epsilon
> instance Subst Term Explicitness
> instance Subst Term Match
> instance Subst Term Pattern
> instance Subst Term Telescope
> instance Subst Term Arg

> substTele :: Telescope -> [ Term ] -> Telescope -> Telescope
> substTele tele args delta = substs (mkSubst tele args) delta where
>   mkSubst Empty [] = []
>   mkSubst (Cons (unrebind->((x,_),tele'))) (tm : args) = 
>        (x,tm) : mkSubst tele' args
>   mkSubst (ConsErased (unrebind->((x,_),tele'))) (tm : args) = 
>        (x,tm) : mkSubst tele' args
>   mkSubst _ _ = error "Internal error: substTele given illegal arguments"