module Lambda0 where

{- 
   A Simple example of an environment based interpreter for a lambda calculus. This example  
   could easily be written in vanilla Haskell or ML. 
-}
  

import Nat
import List

data Exp : Type where
  Var of (Nat)           -- variables, represented with de Bruijn indices
  App of (Exp)(Exp)      -- application
  Lam of (Exp)           -- anonymous functions
  Lit of (Nat)           -- natural number constants
  If0 of (Exp)(Exp)(Exp) -- test for zero

data Val : Type where
  Clos of (List Val)(Exp)  -- a closure: pair of an environment and an expression w/ a free variable
  VNat of (Nat)            -- natural number value


-- List index (subscript) operator, starting from 0.

nth : [a : Type] -> List a -> Nat -> a
nth = \[a] l n. case l of 
  Nil -> TRUSTME -- "index too large"
  Cons x xs -> case n of 
    Zero -> x
    Succ m -> nth [a] xs m

interp : List Val -> Exp -> Val
interp = \ rho exp . case exp of 
   Var x -> nth [Val] rho x 
   App e1 e2 -> 
      let v1 = interp rho e1 in
      let v2 = interp rho e2 in 
      case v1 of 
        Clos rho' body -> 
          interp (Cons v2 rho') body
        VNat i -> TRUSTME
   Lam e -> Clos rho e
   Lit i -> VNat i
   If0 e1 e2 e3 -> 
      case (interp rho e1) of 
        VNat x -> case x of 
          Zero     -> interp rho e2
          (Succ y) -> interp rho e3
        Clos rho exp -> TRUSTME

t1 : interp Nil (App (Lam (Var 0)) (Lit 3)) = VNat 3
t1 = refl

t2 : interp Nil (App (Lam (Var 1)) (Lit 2)) = TRUSTME
t2 = refl

t3 : interp Nil (App (Lit 1) (Lit 2)) = TRUSTME
t3 = refl

t4 : interp Nil (If0 (Lit 1) (Lit 2) (Lit 3)) = VNat 3
t4 = refl